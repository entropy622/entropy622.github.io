[{"content":"react 基础 state同步的注意事项 1 2 3 4 5 6 7 8 9 10 import { useState } from \u0026#39;react\u0026#39;; export default function Clock(props) { const [color, setColor] = useState(props.color); return ( \u0026lt;h1 style={{ color: color }}\u0026gt; {props.time} \u0026lt;/h1\u0026gt; ); } React 状态初始化机制：\nuseState(props.color) 仅在组件 首次渲染时 使用 props.color 的初始值 后续父组件传入的 props.color 变化时，这个初始化代码不会再执行, 造成了color和props的不同步.\n可以简单的改为:\n1 2 3 4 5 6 7 8 9 import { useState } from \u0026#39;react\u0026#39;; export default function Clock(props) { return ( \u0026lt;h1 style={{ color: props.color }}\u0026gt; {props.time} \u0026lt;/h1\u0026gt; ); } 不应该把组件函数的定义嵌套起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { useState } from \u0026#39;react\u0026#39;; export default function MyComponent() { const [counter, setCounter] = useState(0); function MyTextField() { const [text, setText] = useState(\u0026#39;\u0026#39;); return ( \u0026lt;input value={text} onChange={e =\u0026gt; setText(e.target.value)} /\u0026gt; ); } return ( \u0026lt;\u0026gt; \u0026lt;MyTextField /\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setCounter(counter + 1) }}\u0026gt;点击了 {counter} 次\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } 每次点击按钮，输入框的 state 都会消失！这是因为每次 MyComponent 渲染时都会创建一个 不同 的 MyTextField 函数。 在相同位置渲染的是不同的组件，所以 React 将其下所有的 state 都重置了。\n不要在useEffect中改变state 1 2 3 4 const [count, setCount] = useState(0); useEffect(() =\u0026gt; { setCount(count + 1); }); 默认情况下, useEffect会在组件选然后执行, 所以会无限循环。\n没看懂 https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs 深入探讨 如何使用 ref 回调管理 ref 列表\nreact query 我们看一个react query的最小实现:\n最小实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { QueryClient, useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import \u0026#39;./index.css\u0026#39; function App() { const { data, isPending, status } = useQuery({ queryKey: [\u0026#39;dishes\u0026#39;], queryFn: async () =\u0026gt; { return fetch( \u0026#39;http://localhost:8080/admin/dish/page?categoryId=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=10\u0026amp;status=1\u0026#39; ).then(res =\u0026gt; { if (!res.ok) { throw new Error(`请求错误:${res.status}`) } return res.json() }) } }) if (isPending) return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; if (status === \u0026#39;error\u0026#39;) return \u0026lt;div\u0026gt;请求错误\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{JSON.stringify(data)}\u0026lt;/div\u0026gt; } export default App 在这个最小实现中, react query实际包装和抽象了一个通用服务器请求的流程, 这个通用的流程是\u0026quot;创建useState, 发起请求并判断请求的状态(isPending, isError等). 如果请求成功, 将请求存入缓存(useState), 并附上一个 时间戳, 之后在这个queryKey对应的请求数据被用到时(组件重新挂载,窗口聚焦等时期)判断缓存是否过期, 如果过期则重新请求并更新缓存; 如果请求失败, 则隔一段时间继续请求;\u0026quot;\n如果我们不用react query, 那么这个组件的实现应该是这样的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import { useState, useEffect, useRef } from \u0026#39;react\u0026#39; import \u0026#39;./index.css\u0026#39; // 缓存配置 const CACHE_EXPIRY_TIME = 5 * 60 * 1000 // 5分钟缓存有效期 function App() { const [isLoading, setIsLoading] = useState(false) const [error, setError] = useState(null) //数据缓存 const [cache, setCache] = useState({ data: null, timestamp: 0 }) // 重试次数计数器 const maxRetries = 3 const retryRemainRef = useRef(maxRetries) // @ts-ignore async function queryFn() { const response = await fetch( \u0026#39;http://localhost:8080/admin/dish/page?categoryId=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=10\u0026amp;status=1\u0026#39; ) if (!response.ok) { throw new Error(`请求失败，状态码：${response.status}`) } const jsonData = await response.json() // 更新缓存. 但实际上reactQuery会在四种情况下更新缓存: //1. queryKey发生改变. //2. 拥有这个queryKey的组件挂载时 //3. 窗口重新聚焦 //4. 网络重新连接 //这里只模拟了第二种情况. //同时, 在reactQuery里面, 可以通过设置refetchOnMount, refetchOnWindowFocus, //refetchOnReconnect来让后三种情况不触发缓存更新. setCache({ data: jsonData.data?.records, timestamp: Date.now() }) retryRemainRef.current = 0 // 将remain的retry值设置为0, 表示已成功, 不需要接着重试了. } // @ts-ignore async function query(): Promise\u0026lt;void\u0026gt; { setIsLoading(true) setError(null) try { await queryFn() } catch (err) { setError(err.message) // 重试, 重试时间间指数递增 if (retryRemainRef.current \u0026gt;= 0) { const delay = Math.min( 1000 * 2 ** (maxRetries - retryRemainRef.current), 30000 ) setTimeout(() =\u0026gt; { retryRemainRef.current-- queryFn() }, delay) } } finally { setIsLoading(false) } } useEffect(() =\u0026gt; { const now = Date.now() // 在缓存不存在的情况时进行查询 // 检查缓存有效性, 模拟staleTime的机制. if (!cache.data || now - cache.timestamp \u0026gt; CACHE_EXPIRY_TIME) { query() } }, []) // 空依赖表示只在组件挂载时执行 if (isLoading) return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; if (error) return \u0026lt;div\u0026gt;错误：{error}\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{JSON.stringify(cache.data?.slice(0, 10))}\u0026lt;/div\u0026gt; } export default App 显然, react query的实现更简洁, 更易读, 更易维护, 更易扩展(我想谁也不愿意在js里面面对一大堆useState和useEffect). 而且上面不用reactQuery的这一段代码都是复用性很高的, 因此就算不用react query, 我们也应该把这一段逻辑抽象封装起来.\n同时, 由于react query的key机制, react query用起来就像一个键值对数据库. 围绕于此, react也提供了很多实用的机制: 比如减少重复的请求(在缓存中有对应key的数据时, 不会发起请求), 垃圾回收(在一条查询缓存过久(超过gcTime)没有被组件使用后, 会被自动删除),\n实际使用例子 ","date":"2025-03-28T00:00:00Z","image":"https://entropy622.github.io/p/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_hu2051dcf5bed52f28e8b8baafa28f1492_971552_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"react学习笔记"},{"content":"【Catlike Coding】Compute Shader 学了Catlike Coding的basic部分, compute shader部分有点收获,写个总结.\nGPUGraph.cs 通过Shader.propertyToID把数据从C#脚本中传递到shader中(CPU To GPU).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 using UnityEngine; //This is a script to draw a 3D graph by GPU, using simple mesh. public class GPUGraph : MonoBehaviour { // [SerializeField] Transform pointPrefab; // Unused in procedural rendering but kept for reference [SerializeField] int resolution = 200; [SerializeField, Range(0, 2)] private int functionIndex = 0; [SerializeField] ComputeShader positionComputeShader; [SerializeField] Material proceduralMaterial; [SerializeField] Mesh quadMesh; ComputeBuffer positionBuffer; static readonly int PositionsID = Shader.PropertyToID(\u0026#34;_Positions\u0026#34;), ResolutionID = Shader.PropertyToID(\u0026#34;_Resolution\u0026#34;), TimeID = Shader.PropertyToID(\u0026#34;_Time\u0026#34;), FunctionIndexID = Shader.PropertyToID(\u0026#34;_FunctionIndex\u0026#34;); // Added for function selection private void Awake() { // Initialize ComputeBuffer with resolution * resolution elements, each a Vector3 (3 floats) positionBuffer = new ComputeBuffer(resolution * resolution, 3 * sizeof(float)); } void Update() { UpdatePositions(); ProcedureDraw(); } void UpdatePositions() { // Calculate thread groups based on resolution, assuming Compute Shader uses 16x16 threads int threadGroupsX = Mathf.CeilToInt(resolution / 16.0f); int threadGroupsY = Mathf.CeilToInt(resolution / 16.0f); // Set Compute Shader parameters positionComputeShader.SetInt(ResolutionID, resolution); positionComputeShader.SetFloat(TimeID, Time.time); positionComputeShader.SetInt(FunctionIndexID, functionIndex); // Set the function index // Set the buffer and dispatch the Compute Shader int kernel = positionComputeShader.FindKernel(\u0026#34;CalculatePositions\u0026#34;); positionComputeShader.SetBuffer(kernel, PositionsID, positionBuffer); positionComputeShader.Dispatch(kernel, threadGroupsX, threadGroupsY, 1); // Vector3[] positions = new Vector3[resolution * resolution]; // positionBuffer.GetData(positions); // Debug.Log(\u0026#34;Position[0]: \u0026#34; + positions[0]); } void ProcedureDraw() { // Ensure the material has the latest position buffer proceduralMaterial.SetBuffer(\u0026#34;_Positions\u0026#34;, positionBuffer); // Draw instanced meshes procedurally Graphics.DrawMeshInstancedProcedural( quadMesh, 0, proceduralMaterial, new Bounds(Vector3.zero, Vector3.one * 10f), resolution * resolution ); } private void OnDestroy() { // Release the buffer to prevent memory leaks positionBuffer.Release(); } } GraphComputeShader.compute compute shader 计算好坐标,并返回给缓冲区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #pragma kernel CalculatePositions RWStructuredBuffer\u0026lt;float3\u0026gt; _Positions; uint _Resolution; float _Time; uint _FunctionIndex; // 注意：这里是 __FunctionIndex，与你的代码保持一致 #define PI 3.14159265358979323846 // 函数1：原始的绘图函数 float3 Function1(float u, float v, float time) { float r1 = (7.0 + sin(PI * (6.0 * u + time / 2.0))) / 10.0; float r2 = (3.0 + sin(PI * (4.0 * v + 8.0 * u + 2.0 * time))) / 20.0; float s = r1 + r2 * cos(PI * v); float3 position; position.x = s * sin(PI * u); position.z = s * cos(PI * u); position.y = r2 * sin(PI * v); return position; } // 函数2：示例函数（简单平面） float3 Function2(float u, float v, float time) { float3 position; position.x = u; position.y = 0.0; position.z = v; return position; } // 函数3：示例函数（波浪面） float3 Function3(float u, float v, float time) { float3 position; position.x = u; position.y = sin(u * 5.0 + time) * 0.5; position.z = v; return position; } // 线程组配置 [numthreads(16, 16, 1)] void CalculatePositions (uint3 id : SV_DispatchThreadID) { // 索引保护，避免越界 if (id.x \u0026gt;= _Resolution || id.y \u0026gt;= _Resolution) return; // 归一化计算，确保 u 和 v 在 [-4, 4] 范围内 float step = 8.0 / (_Resolution - 1); float u = -4.0 + step * id.x; float v = -4.0 + step * id.y; // 根据 __FunctionIndex 选择不同的绘图函数 float3 position; switch (_FunctionIndex) { case 0: position = Function1(u, v, _Time); break; case 1: position = Function2(u, v, _Time); break; case 2: position = Function3(u, v, _Time); break; default: position = float3(0, 0, 0); // 默认值，防止未定义行为 break; } // 计算缓冲区索引并写入结果 uint index = id.y * _Resolution + id.x; // 行优先存储 _Positions[index] = position; } Catlike shader 是surface shader,在我2022 URP Unity中不能使用. 所以我让AI改为了 URP shader.\n通过\n1 2 3 #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) // Get the position for this instance float3 position = _Positions[unity_InstanceID]; 来获取缓冲区内的坐标,然后改变unity object to world 矩阵, 来改变坐标. 挺巧妙的.\nProcedureDraw.shader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Shader \u0026#34;Custom/ProceduralSurfaceURP\u0026#34; { Properties { _Scale (\u0026#34;Instance Scale\u0026#34;, Range(0.001, 0.05)) = 0.005 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;RenderPipeline\u0026#34;=\u0026#34;UniversalPipeline\u0026#34; } Pass { HLSLPROGRAM #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\u0026#34; #pragma vertex vert #pragma fragment frag #pragma multi_compile_instancing #pragma instancing_options procedural:ConfigureProcedural #pragma target 4.5 #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) StructuredBuffer\u0026lt;float3\u0026gt; _Positions; // Buffer to receive positions from C# #endif float _Scale; struct Attributes { float4 positionOS : POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float4 positionCS : SV_POSITION; float3 worldPos : TEXCOORD0; }; void ConfigureProcedural() { #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) // Get the position for this instance float3 position = _Positions[unity_InstanceID]; // Build the transformation matrix: scale and translate float4x4 mat = float4x4( _Scale, 0, 0, position.x, 0, _Scale, 0, position.y, 0, 0, _Scale, position.z, 0, 0, 0, 1 ); // Apply the transformation to UNITY_MATRIX_M (object to world matrix) UNITY_MATRIX_M = mat; #endif } Varyings vert(Attributes input) { Varyings output; UNITY_SETUP_INSTANCE_ID(input); output.positionCS = TransformObjectToHClip(input.positionOS.xyz); output.worldPos = TransformObjectToWorld(input.positionOS.xyz); return output; } half4 frag(Varyings input) : SV_Target { half3 color = 0.5 + 0.5 * sin(input.worldPos); return half4(color, 1); } ENDHLSL } } } 总结 这一套方案让CPU运算量大大降低. 戴森球的优化应该也采用类似的方法, 把各种CPU的计算转移到GPU中进行. 大概效率提升了一个数量级.\n戴森球作者发的专栏 https://www.zhihu.com/question/442555442/answer/1711890146?utm_psn=1883875216381432992\n","date":"2025-03-11T00:00:00Z","image":"https://entropy622.github.io/p/2025spring-catlike-codingcompute-shader/Unity_hu12310998fa897105b281302b8594aee5_487097_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2025spring-catlike-codingcompute-shader/","title":"2025spring 【Catlike Coding】Compute Shader"},{"content":"2025spring 学期总结 上 黑马 学完了java_web_ai那门公开课。还不错。学到了前后端的基本知识，也巩固了从CS61A那里学的数据库知识。\n学校红黑榜 靠着黑马公开课的底子，给学校做了一个红黑榜单，大部分工作是我一个人做的。\n技术栈是Vue+Spring+MySQL，前端还用了ElementPlus。服务器用的阿里云的99包年（确实便宜）。但是备案是不可能备案成功的了， 所以直接用的域名来传播。\n学了点爬虫知识，把学校sis上的课程记录给爬了下来。\n做了一个简单的邮箱登录系统。\n整个过程中，AI的帮助确实是很大的。节省了非常多的时间，也从AI那里学到了很多。一个感触是：在AI时代下，我们的学习或许可以逐步从 “我会做” 变成 “我知道能这么做”。\n在进行的 蹭上了南大jyy的计算机系统原理，正在好好听。好课。\n学习总体 总体来说，我的课外学习时间是比上学期缩减挺多的。可能热情下降了一点吧。\n生活 天天宅家，宅寝室。没体育课了，也彻底不会去运动了。似乎不太好。但是我确实不喜欢运动，就不强迫自己干不喜欢的事情了。\n文化 还是蛮丰富的。\n看了一些番： 《素晴》全系列、《堕落的珈百璃》。笑的很开心，喜欢惠惠。\n有点喜欢上了肉鸽卡牌：重温了杀戮尖塔的崩坠，玩了三十个小时的《超时空方舟》。挺有意思。但是不能继续玩下去了。\n前天周末花了一下午和晚上看完了《饿殍-明末千里行》。现在胸口依然隐隐难受。应该会是我人生中很难忘却的一部作品吧。\n满穗太可爱了，也很让人有一种保护欲。我觉得我对这种人物没有抵抗力。 走路总是想到其中的情节，也总是叹气。明末千里行是我的第一部通的AVG。这或许就是所谓玩完gal的后劲吧。 类似的体验发生在我玩完《终焉之莉莉》后，看完《来自深渊》后，看完《声之形》后。但这种感觉，虽然有点难受，但我认为也是幸福的。 是享受完一部好作品后的怅惘，失落，也是等待续作时候都急切与希冀。这也是人生的意义所在啊。\n最近很急切的去补了一些明末历史和南明历史。买了顾明先生的《南明史》准备看。\n好喜欢满穗。\n说起莉莉，莉莉的续作木兰花其实让我失望。虽然乐在其中的玩完了，但是几乎没有留下印象深刻的情节。\n计划 看《南明史》，今天开始学 catlike coding for unity and C#。 继续跟着jyy2025年的课程学计算机系统。\n","date":"2025-03-11T00:00:00Z","image":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/mansui_huf44d5a27bdf3c47bbf41f99fa97b4ff1_472467_120x120_fill_q75_box_smart1.jpg","permalink":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/","title":"2025spring 学期总结 上"},{"content":"2024fall 学期总结 暑假 暑假开始学c++，在leetcode上做了一些题，同时在学games101，但实际上，由于代码能力过于欠缺，101的作业只做了前面三个。收获并不大，需要在之后重修。\n八月份开始了解npr相关的东西，同时在看《Unity shader 入门精要》。学了一点HLSL。 开始用Unity URP 管线做点项目，磕磕绊绊做了几个星期，复刻了原和崩铁的渲染。\n实际效果看上去还不错，但可能很难应用到具体的项目中。\n九月 刚入学那会主要是熟悉了一下新环境，继续在leetcode上做点题，完善一下仿崩铁渲染的项目。同时，你知道的，连续玩了十几天黑神话。入坑了终焉的莉莉，看完了来自深渊，这是两部给我留下深刻印象的作品。\n十月 国庆节跟着学校的游戏研究社团参加了ld56（72h的gamejam）。国庆假的前四天主要是继续学习了unity的其他组件，跟教程做了一个2D top-down 游戏的小demo。为几天后的gamejam准备了一个简单的对话系统。\n国庆的后三天是非常紧张的gamejam。睡了两天的会议室。在最后一天，面对不敢相信能做完的工作量，熬到了十月八号凌晨六点终于做完了。第一次看到了龙大早上六点的太阳。\n很累，但是实在是我不可多得的宝贵经历。第一次接触比较大型的项目，第一次用git搞团队合作开发。开发能力也得到了很大的进步。\n做了一个横版2D游戏 但最后的排名并不好，后来我反思得出的结论是：做的体量太大，远远超出了一个gamejam应该有点体量（初次游玩大概一个小时），倒是最终我们只能实现一堆最基本的东西，而没有实现让一个游戏变得更好玩，更有趣的部分。 去了mihoyo的校招会，是我这个学期碰上最大的乐子 在学校的万圣节晚会上出了希露菲叶特\n转向luogu刷题了。gamejam后面的几个星期挺累的，没有做什么coding的项目。\n学了学blender，建模和风格化渲染的内容。跟着夏森轄的演示做了一个小人。 本来还想在blender里面复刻在unity中实现的仿崩铁渲染的，但是这个安排搁置了。\n十一月和十二月 入坑了csdiy https://csdiy.wiki/ 由于学校教的是java，所以我就从cs61b开始学了。说实话真的是一门很好的课。 project2 要求实现一个 mini git，是我收获最大的项目。 project3 实现了一个随机地图生成算法，以及一个小小的随机迷宫小游戏demo。也是很有意思的。 后面听说期末要考python，所以我在cs61b快学完的时候，也去把61a的lab和proj完成了。不得不说，仍然收获巨大。scheme，数据库，深入的匿名函数，函数指针，这些是在61b学不到的。 但是期末考试只考了一道很简单的python选择题\n学cs61学的十分起劲啊，学完61ab后一口做气又冲向了61c。但很快遇到了很大的挑战。首先是c语言编写的project1的环境配置，搞了很久没搞成。同时我也并不喜欢这个项目，于是就嫖了南大的c语言大作业来代替。主要内容是实现一个魔改、极简的命令行html解释器。 很有趣，也很有意思的项目。感谢南大。\n后面感觉自己对cs61c的学习兴趣远没有cs61ab大了，没有动力去做61c的大作业。于是在选取了部分61c的讲座听完后，我就放下了cs61c。\n这段时间我开始慢慢停止刷leetcode和luogu了，原因大概是三个。一是觉得刷题远没有做项目有意思，二是感觉一直刷题无法建立我的实际工程能力，三是我逐渐放弃了学期开始希望打ACM的打算。\n两个题站加起来总共刷了三百道，对我的帮助也是大的，不然学cs61的时候会遇到更多的困难。\n刷题虽好，不要沉迷。\n十二月下旬~至今 沉迷live2D，收集了b站的一堆免费皮套。天天对着VTS的面部摄像机挤眉弄眼。\n后来想把live2D形象放在桌面上，做成一个类似桌宠的玩意，但是苦于没有相关的插件，没有找到一个现成的好用的方案。\n然后我去学了一点点windows桌面应用开发。做了一个很小型的软件。期间最大的挑战是找不到一个能用的获取VTS虚拟摄像机的.net库。directShow虽然可以捕获到这个虚拟摄像头，但是输出不带透明度信息。\n于是想办法实现了一个简单的纯色背景去除算法，简单的hack了一下，让人物身上与背景相似的小色块不会被误除。 开始学黑马的web课程，在这过程中也准备搭一个个人博客。本来想从零手搓，但感觉太难了，放弃了。 之后采用hugo + stack的方案来搭建博客，同时引入了live2D桌宠。最后的成果就是这个网站。 未来规划 继续学黑马，学《计算机网络 自顶向下方法》。补完games101的作业。学UE。\n总结 这学期应该还是做了蛮多东西的。 当然是天天翘课导致的，一周下来只去上了体育课和英语课\n但我觉得我的目标变得不明确了。学期开始时候，我觉得我以后就是搞图形了。还去找了学校的图形学教授。但是现在我已经说不出这种话了。\n大一下学线代的时候（我现在已经开始第二学期的课程了），助教问我们矩阵乘法有什么意义，我回答了图形学中两个transformtion矩阵相乘的例子。助教下课问我是不是想搞图形学，我情不自禁回答了：“在学，但不会很深入。”\n转变的原因主要有两个吧：一是就业压力，在当前的环境下，图形学的前辈几乎都在劝退，我实在不敢在已经很糟糕的就业环境下，选择一条更加不好就业的道路。二是对困难的畏惧，图形确实挺难的。\n我似乎走上了一条更大众的道路。不过我也乐在其中，做web、wpf开发，也蛮有意思的。\n我对计算机的爱好还比较广泛。前端后端想搞，unity，ue想搞，blender也想搞，也有去学houdini的想法。有的时候会觉得自己学的东西似乎有点太杂了。\n应该尽快明确精进的方向。\n","date":"2025-01-18T00:00:00Z","image":"https://entropy622.github.io/p/2024fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/image_huf94238997220ab437e4c2645719d6d7e_184045_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2024fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/","title":"2024fall 学期总结"},{"content":"图片 三级标题 四级标题 强调\n有序列表 有序列表 有序列表 ？？ 有序列表 10 11 五级^标题^ fklsjdlksjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfkls 下划线 删除线 a上标 a下标 高亮\n链接 链接 [百度](URL_ADDRESS百度\n列表 $$ \\sum_{i=1}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} $$ $$ \\int_0^\\infty e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2} $$ $$\njack bush can 1 2 3 4 5 6 7 8 9 code 1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-01-17T00:00:00Z","image":"https://entropy622.github.io/p/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87/avatar_hud9e0e7c4951e871acf83365066e399f1_1041756_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87/","title":"测试"}]