[{"content":"学习 到十月为止,主要是继续做tuan-chat。但之后就没什么动力了，在最初的，第一次做大项目的激情过后，剩下的就只有班味了。 暑假的时候把cs168学完了，但之后就很少再去自学新的东西了。\n生活 玩了环世界，泰拉瑞亚灾厄，mc的ATM9整合包。\n荒诞 很多时候会有虚无感。毕业后，自己以后就算拼死拼活找到了一份工作，也得拼死拼活去加班。哪怕我对计算机有热爱，在毕业前很勤奋的为自己装备了哪怕在现在这个时代也足够在职场生存的技能，到头来还是要成为公司的耗材，时代的灰烬。 所有的这些，都不会给我带来一个更好的未来。 当我更重度的使用AI后，这种虚无感更严重了。很多时候都会觉得：“学这些有什么用呢？反正AI做的够好了”\n十一月，突然想学学板绘了。上个周末临摹了一张rurudo的画。 倒也挺开心\n未来如何呢。现在大概设想毕业没有找到合适的工作就去直博（直博名额已经有了）。找到了，看工作强度，勉勉强强干几千，攒点钱回小县城躺平。\n","date":"2025-11-10T00:00:00Z","image":"https://entropy622.github.io/p/2025fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/img_hub1a6188940f18ec486e77722194c4590_1657957_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2025fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/","title":"2025fall 学期总结 上"},{"content":"学习 主要是继续做tuan-chat。追完了jyy的计算机系统原理。\n生活 玩完了p5r\n今天 今天和星爷畅谈了几个小时。从tuan-chat到unity开发，到人生规划与教育现状和改革，很开心\n明天 学习mallchat 给webgal交pr（同时好好学学nodejs） UCB cs168 计算机网络 黑马点评 ","date":"2025-06-08T00:00:00Z","image":"https://entropy622.github.io/p/2025summer-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/img_huf81f129d0e14550635ab8508ff72fcf6_2352433_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2025summer-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/","title":"2025summer 学期总结 上"},{"content":"2025spring 学期总结 下 tuan-chat 第一件事肯定是跟着星爷去做这个项目了。是一个跑团平台。我的任务是react前端。与其说是实习，更像一个开源项目。\n在这之前恶补了两个星期的react，在有压力的情况下效率还比较高。 正式开始开发后，一开始是很紧张的，不过也很快适应了。几个星期的开发颇有收获，是在大一难得的经历。\n关于软件工程中解耦内聚等概念，也是在开发这么一个较大的项目后才慢慢理解的。\n学习 继续学jyy的计算机系统，不过没时间做lab了。但是感觉光听课收获比较少。\n花了几天快速过完了苍穹外卖。\n恶补了react和tailwind相关的知识。\n生活 由于忙着做项目去了，摆的也少了。\n看了《金牌得主》，看到了自己和别人的影子。\n玩了《苍翼-混沌效应》，挺好的肉鸽横板动作，可惜最大的缺点就是肉鸽的随机性太差了。\n玩了《图灵完备》，四小时的体验，从基础的逻辑电路到一台最简单的可编程计算机，是一段很开心的旅程，也是一次效率挺高的学习。 之前没有做CS61c的作业，靠这个算补上一点。\n总结 由于忙于项目，有点压力，所以学习效率还挺高的。比上一个月的状态好多了。\n比前半学期肯定更忙了，但也挺快活的。\n有的时候其实也感觉来LGU挺好的。要是高考考得高一点去了别的学校，我估计就要忙于应付课内的任务了， 也不可能在大一点了不少的技能树，也不太可能有时间跟着星爷做项目。\n暑期 这个学期就要过完了。暑期有三个多月的时间。初步想了一点任务：\n接着在星爷那边做项目，暂时不确定做到多久。 用spout2把VTBcat的项目重构了，让它能成为一个真正好用的VTS插件。（这个时候感觉c/c++还是要学好） 补完jyy计算机系统上的lab。 ","date":"2025-04-23T00:00:00Z","image":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8B/img_hu23b66a974b74c0b6e423bc18931b0c28_1511052_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8B/","title":"2025spring 学期总结 下"},{"content":"南大jyy老师在他的计算机实验课的实验须知上, 贴上了这么一段要求: 很赞同. AI对学习的帮助很大, 但是滥用也会造成不可挽回的后果.\n具体来说, 对于刚接触某一个计算机方面的初学者(比如刚学react, 刚学spring后端)来说, 以下几个原则是建议遵守的(也是我吃过苦头或者看到别人吃苦头总结出来的, 现在时刻提醒自己的)\nAI给你了一段代码, 绝对不要糊里糊涂的就直接粘贴上去. 一定要自己阅读, 读懂. 这个时候让AI再去给你详细的解释一下, 也不失一个好方法. 作为初学者, 做什么项目, 也绝对不要抱着让AI生成一个然后让自己满足的心态去做. 无论如何, 现在做项目的目的还是为了学东西. 绝对不要绝对AI写了什么东西, 然后产生了自己很厉害的错觉. 如果你在AI的帮助下都不能完全读懂AI给你的代码, 说明你该去看文档, 看教程. 或者直接放弃这个地方. 如果在上述情况下还硬着头皮去写, 那么你之后的情况很可能是: 跑一下, 不对, 把报错粘贴给AI, 重复这个过程许多次, 然后你没有任何收获, 成了AI大人的CV奴隶 AI总是喜欢搞增量开发, 所以在AI给你debug你看不懂的代码的时候, 如果一两次搞不出来, 那么很可能AI要十几次才能从 他陷入的逻辑中挣扎出来(这tm也真像人类). 但是不同的地方在于, 人在这种不断挣扎的过程中收获颇丰, 而你这个CV奴隶只能 收获一堆坏心情. (3的补充)不要在这种觉得你很厉害的错觉下, 去做一个你几乎不懂的项目. 这种情况下, 你基本上是会读不懂AI的代码的, 然后在AI给你的错觉和自信下, 你又去死磕这个项目, 最后大概就变成AI大人的CV奴隶了. 在CV奴隶的状态下, 项目的开发速度常常也是极慢的, 一方面AI只会增量开发, 在开发的总代码量到一个数量级后, 你看不懂这个代码了, AI由于上下文限制也不能搞懂你代码的全局了, 最后涌现出一堆AI与你都无法修复的bug, 项目进度也就变得极慢甚至停顿, 废弃. ","date":"2025-04-01T00:00:00Z","image":"https://entropy622.github.io/p/%E4%B8%8D%E8%A6%81%E5%8F%98%E6%88%90ai%E5%A4%A7%E4%BA%BA%E7%9A%84cv%E5%A5%B4%E9%9A%B6/img_1_hu1e561b619e6ee7713a64202668869e07_35065_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/%E4%B8%8D%E8%A6%81%E5%8F%98%E6%88%90ai%E5%A4%A7%E4%BA%BA%E7%9A%84cv%E5%A5%B4%E9%9A%B6/","title":"不要变成AI大人的CV奴隶"},{"content":"react 基础 state同步的注意事项 1 2 3 4 5 6 7 8 9 10 import { useState } from \u0026#39;react\u0026#39;; export default function Clock(props) { const [color, setColor] = useState(props.color); return ( \u0026lt;h1 style={{ color: color }}\u0026gt; {props.time} \u0026lt;/h1\u0026gt; ); } React 状态初始化机制：\nuseState(props.color) 仅在组件 首次渲染时 使用 props.color 的初始值 后续父组件传入的 props.color 变化时，这个初始化代码不会再执行, 造成了color和props的不同步.\n可以简单的改为:\n1 2 3 4 5 6 7 8 9 import { useState } from \u0026#39;react\u0026#39;; export default function Clock(props) { return ( \u0026lt;h1 style={{ color: props.color }}\u0026gt; {props.time} \u0026lt;/h1\u0026gt; ); } 不应该把组件函数的定义嵌套起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { useState } from \u0026#39;react\u0026#39;; export default function MyComponent() { const [counter, setCounter] = useState(0); function MyTextField() { const [text, setText] = useState(\u0026#39;\u0026#39;); return ( \u0026lt;input value={text} onChange={e =\u0026gt; setText(e.target.value)} /\u0026gt; ); } return ( \u0026lt;\u0026gt; \u0026lt;MyTextField /\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setCounter(counter + 1) }}\u0026gt;点击了 {counter} 次\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } 每次点击按钮，输入框的 state 都会消失！这是因为每次 MyComponent 渲染时都会创建一个 不同 的 MyTextField 函数。 在相同位置渲染的是不同的组件，所以 React 将其下所有的 state 都重置了。\n不要在useEffect中改变state 1 2 3 4 const [count, setCount] = useState(0); useEffect(() =\u0026gt; { setCount(count + 1); }); 默认情况下, useEffect会在组件选然后执行, 所以会无限循环。\n没看懂 https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs 深入探讨 如何使用 ref 回调管理 ref 列表\nreact query 我们看一个react query的最小实现:\n最小实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { QueryClient, useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import \u0026#39;./index.css\u0026#39; function App() { const { data, isPending, status } = useQuery({ queryKey: [\u0026#39;dishes\u0026#39;], queryFn: async () =\u0026gt; { return fetch( \u0026#39;http://localhost:8080/admin/dish/page?categoryId=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=10\u0026amp;status=1\u0026#39; ).then(res =\u0026gt; { if (!res.ok) { throw new Error(`请求错误:${res.status}`) } return res.json() }) } }) if (isPending) return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; if (status === \u0026#39;error\u0026#39;) return \u0026lt;div\u0026gt;请求错误\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{JSON.stringify(data)}\u0026lt;/div\u0026gt; } export default App 在这个最小实现中, react query实际包装和抽象了一个通用服务器请求的流程, 这个通用的流程是\u0026quot;创建useState, 发起请求并判断请求的状态(isPending, isError等). 如果请求成功, 将请求存入缓存(useState), 并附上一个 时间戳, 之后在这个queryKey对应的请求数据被用到时(组件重新挂载,窗口聚焦等时期)判断缓存是否过期, 如果过期则重新请求并更新缓存; 如果请求失败, 则隔一段时间继续请求;\u0026quot;\n如果我们不用react query, 那么这个组件的实现应该是这样的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import { useState, useEffect, useRef } from \u0026#39;react\u0026#39; import \u0026#39;./index.css\u0026#39; // 缓存配置 const CACHE_EXPIRY_TIME = 5 * 60 * 1000 // 5分钟缓存有效期 function App() { const [isLoading, setIsLoading] = useState(false) const [error, setError] = useState(null) //数据缓存 const [cache, setCache] = useState({ data: null, timestamp: 0 }) // 重试次数计数器 const maxRetries = 3 const retryRemainRef = useRef(maxRetries) // @ts-ignore async function queryFn() { const response = await fetch( \u0026#39;http://localhost:8080/admin/dish/page?categoryId=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=10\u0026amp;status=1\u0026#39; ) if (!response.ok) { throw new Error(`请求失败，状态码：${response.status}`) } const jsonData = await response.json() // 更新缓存. 但实际上reactQuery会在四种情况下更新缓存: //1. queryKey发生改变. //2. 拥有这个queryKey的组件挂载时 //3. 窗口重新聚焦 //4. 网络重新连接 //这里只模拟了第二种情况. //同时, 在reactQuery里面, 可以通过设置refetchOnMount, refetchOnWindowFocus, //refetchOnReconnect来让后三种情况不触发缓存更新. setCache({ data: jsonData.data?.records, timestamp: Date.now() }) retryRemainRef.current = 0 // 将remain的retry值设置为0, 表示已成功, 不需要接着重试了. } // @ts-ignore async function query(): Promise\u0026lt;void\u0026gt; { setIsLoading(true) setError(null) try { await queryFn() } catch (err) { setError(err.message) // 重试, 重试时间间指数递增 if (retryRemainRef.current \u0026gt;= 0) { const delay = Math.min( 1000 * 2 ** (maxRetries - retryRemainRef.current), 30000 ) setTimeout(() =\u0026gt; { retryRemainRef.current-- queryFn() }, delay) } } finally { setIsLoading(false) } } useEffect(() =\u0026gt; { const now = Date.now() // 在缓存不存在的情况时进行查询 // 检查缓存有效性, 模拟staleTime的机制. if (!cache.data || now - cache.timestamp \u0026gt; CACHE_EXPIRY_TIME) { query() } }, []) // 空依赖表示只在组件挂载时执行 if (isLoading) return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; if (error) return \u0026lt;div\u0026gt;错误：{error}\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{JSON.stringify(cache.data?.slice(0, 10))}\u0026lt;/div\u0026gt; } export default App 显然, react query的实现更简洁, 更易读, 更易维护, 更易扩展(我想谁也不愿意在js里面面对一大堆useState和useEffect). 而且上面不用reactQuery的这一段代码都是复用性很高的, 因此就算不用react query, 我们也应该把这一段逻辑抽象封装起来.\n同时, 由于react query的key机制, react query用起来就像一个键值对数据库. 围绕于此, react也提供了很多实用的机制: 比如减少重复的请求(在缓存中有对应key的数据时, 不会发起请求), 垃圾回收(在一条查询缓存过久(超过gcTime)没有被组件使用后, 会被自动删除),\n实际使用例子 ","date":"2025-03-28T00:00:00Z","image":"https://entropy622.github.io/p/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_hu2051dcf5bed52f28e8b8baafa28f1492_971552_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"react学习笔记"},{"content":"【Catlike Coding】Compute Shader 学了Catlike Coding的basic部分, compute shader部分有点收获,写个总结.\nGPUGraph.cs 通过Shader.propertyToID把数据从C#脚本中传递到shader中(CPU To GPU).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 using UnityEngine; //This is a script to draw a 3D graph by GPU, using simple mesh. public class GPUGraph : MonoBehaviour { // [SerializeField] Transform pointPrefab; // Unused in procedural rendering but kept for reference [SerializeField] int resolution = 200; [SerializeField, Range(0, 2)] private int functionIndex = 0; [SerializeField] ComputeShader positionComputeShader; [SerializeField] Material proceduralMaterial; [SerializeField] Mesh quadMesh; ComputeBuffer positionBuffer; static readonly int PositionsID = Shader.PropertyToID(\u0026#34;_Positions\u0026#34;), ResolutionID = Shader.PropertyToID(\u0026#34;_Resolution\u0026#34;), TimeID = Shader.PropertyToID(\u0026#34;_Time\u0026#34;), FunctionIndexID = Shader.PropertyToID(\u0026#34;_FunctionIndex\u0026#34;); // Added for function selection private void Awake() { // Initialize ComputeBuffer with resolution * resolution elements, each a Vector3 (3 floats) positionBuffer = new ComputeBuffer(resolution * resolution, 3 * sizeof(float)); } void Update() { UpdatePositions(); ProcedureDraw(); } void UpdatePositions() { // Calculate thread groups based on resolution, assuming Compute Shader uses 16x16 threads int threadGroupsX = Mathf.CeilToInt(resolution / 16.0f); int threadGroupsY = Mathf.CeilToInt(resolution / 16.0f); // Set Compute Shader parameters positionComputeShader.SetInt(ResolutionID, resolution); positionComputeShader.SetFloat(TimeID, Time.time); positionComputeShader.SetInt(FunctionIndexID, functionIndex); // Set the function index // Set the buffer and dispatch the Compute Shader int kernel = positionComputeShader.FindKernel(\u0026#34;CalculatePositions\u0026#34;); positionComputeShader.SetBuffer(kernel, PositionsID, positionBuffer); positionComputeShader.Dispatch(kernel, threadGroupsX, threadGroupsY, 1); // Vector3[] positions = new Vector3[resolution * resolution]; // positionBuffer.GetData(positions); // Debug.Log(\u0026#34;Position[0]: \u0026#34; + positions[0]); } void ProcedureDraw() { // Ensure the material has the latest position buffer proceduralMaterial.SetBuffer(\u0026#34;_Positions\u0026#34;, positionBuffer); // Draw instanced meshes procedurally Graphics.DrawMeshInstancedProcedural( quadMesh, 0, proceduralMaterial, new Bounds(Vector3.zero, Vector3.one * 10f), resolution * resolution ); } private void OnDestroy() { // Release the buffer to prevent memory leaks positionBuffer.Release(); } } GraphComputeShader.compute compute shader 计算好坐标,并返回给缓冲区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #pragma kernel CalculatePositions RWStructuredBuffer\u0026lt;float3\u0026gt; _Positions; uint _Resolution; float _Time; uint _FunctionIndex; // 注意：这里是 __FunctionIndex，与你的代码保持一致 #define PI 3.14159265358979323846 // 函数1：原始的绘图函数 float3 Function1(float u, float v, float time) { float r1 = (7.0 + sin(PI * (6.0 * u + time / 2.0))) / 10.0; float r2 = (3.0 + sin(PI * (4.0 * v + 8.0 * u + 2.0 * time))) / 20.0; float s = r1 + r2 * cos(PI * v); float3 position; position.x = s * sin(PI * u); position.z = s * cos(PI * u); position.y = r2 * sin(PI * v); return position; } // 函数2：示例函数（简单平面） float3 Function2(float u, float v, float time) { float3 position; position.x = u; position.y = 0.0; position.z = v; return position; } // 函数3：示例函数（波浪面） float3 Function3(float u, float v, float time) { float3 position; position.x = u; position.y = sin(u * 5.0 + time) * 0.5; position.z = v; return position; } // 线程组配置 [numthreads(16, 16, 1)] void CalculatePositions (uint3 id : SV_DispatchThreadID) { // 索引保护，避免越界 if (id.x \u0026gt;= _Resolution || id.y \u0026gt;= _Resolution) return; // 归一化计算，确保 u 和 v 在 [-4, 4] 范围内 float step = 8.0 / (_Resolution - 1); float u = -4.0 + step * id.x; float v = -4.0 + step * id.y; // 根据 __FunctionIndex 选择不同的绘图函数 float3 position; switch (_FunctionIndex) { case 0: position = Function1(u, v, _Time); break; case 1: position = Function2(u, v, _Time); break; case 2: position = Function3(u, v, _Time); break; default: position = float3(0, 0, 0); // 默认值，防止未定义行为 break; } // 计算缓冲区索引并写入结果 uint index = id.y * _Resolution + id.x; // 行优先存储 _Positions[index] = position; } Catlike shader 是surface shader,在我2022 URP Unity中不能使用. 所以我让AI改为了 URP shader.\n通过\n1 2 3 #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) // Get the position for this instance float3 position = _Positions[unity_InstanceID]; 来获取缓冲区内的坐标,然后改变unity object to world 矩阵, 来改变坐标. 挺巧妙的.\nProcedureDraw.shader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Shader \u0026#34;Custom/ProceduralSurfaceURP\u0026#34; { Properties { _Scale (\u0026#34;Instance Scale\u0026#34;, Range(0.001, 0.05)) = 0.005 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;RenderPipeline\u0026#34;=\u0026#34;UniversalPipeline\u0026#34; } Pass { HLSLPROGRAM #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\u0026#34; #pragma vertex vert #pragma fragment frag #pragma multi_compile_instancing #pragma instancing_options procedural:ConfigureProcedural #pragma target 4.5 #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) StructuredBuffer\u0026lt;float3\u0026gt; _Positions; // Buffer to receive positions from C# #endif float _Scale; struct Attributes { float4 positionOS : POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float4 positionCS : SV_POSITION; float3 worldPos : TEXCOORD0; }; void ConfigureProcedural() { #if defined(UNITY_PROCEDURAL_INSTANCING_ENABLED) // Get the position for this instance float3 position = _Positions[unity_InstanceID]; // Build the transformation matrix: scale and translate float4x4 mat = float4x4( _Scale, 0, 0, position.x, 0, _Scale, 0, position.y, 0, 0, _Scale, position.z, 0, 0, 0, 1 ); // Apply the transformation to UNITY_MATRIX_M (object to world matrix) UNITY_MATRIX_M = mat; #endif } Varyings vert(Attributes input) { Varyings output; UNITY_SETUP_INSTANCE_ID(input); output.positionCS = TransformObjectToHClip(input.positionOS.xyz); output.worldPos = TransformObjectToWorld(input.positionOS.xyz); return output; } half4 frag(Varyings input) : SV_Target { half3 color = 0.5 + 0.5 * sin(input.worldPos); return half4(color, 1); } ENDHLSL } } } 总结 这一套方案让CPU运算量大大降低. 戴森球的优化应该也采用类似的方法, 把各种CPU的计算转移到GPU中进行. 大概效率提升了一个数量级.\n戴森球作者发的专栏 https://www.zhihu.com/question/442555442/answer/1711890146?utm_psn=1883875216381432992\n","date":"2025-03-11T00:00:00Z","image":"https://entropy622.github.io/p/2025spring-catlike-codingcompute-shader/Unity_hu12310998fa897105b281302b8594aee5_487097_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2025spring-catlike-codingcompute-shader/","title":"2025spring 【Catlike Coding】Compute Shader"},{"content":"2025spring 学期总结 上 黑马 学完了java_web_ai那门公开课。还不错。学到了前后端的基本知识，也巩固了从CS61A那里学的数据库知识。\n学校红黑榜 靠着黑马公开课的底子，给学校做了一个红黑榜单，大部分工作是我一个人做的。\n技术栈是Vue+Spring+MySQL，前端还用了ElementPlus。服务器用的阿里云的99包年（确实便宜）。但是备案是不可能备案成功的了， 所以直接用的域名来传播。\n学了点爬虫知识，把学校sis上的课程记录给爬了下来。\n做了一个简单的邮箱登录系统。\n整个过程中，AI的帮助确实是很大的。节省了非常多的时间，也从AI那里学到了很多。一个感触是：在AI时代下，我们的学习或许可以逐步从 “我会做” 变成 “我知道能这么做”。\n在进行的 蹭上了南大jyy的计算机系统原理，正在好好听。好课。\n学习总体 总体来说，我的课外学习时间是比上学期缩减挺多的。可能热情下降了一点吧。\n生活 天天宅家，宅寝室。没体育课了，也彻底不会去运动了。似乎不太好。但是我确实不喜欢运动，就不强迫自己干不喜欢的事情了。\n文化 还是蛮丰富的。\n看了一些番： 《素晴》全系列、《堕落的珈百璃》。笑的很开心，喜欢惠惠。\n有点喜欢上了肉鸽卡牌：重温了杀戮尖塔的崩坠，玩了三十个小时的《超时空方舟》。挺有意思。但是不能继续玩下去了。\n前天周末花了一下午和晚上看完了《饿殍-明末千里行》。现在胸口依然隐隐难受。应该会是我人生中很难忘却的一部作品吧。\n满穗太可爱了，也很让人有一种保护欲。我觉得我对这种人物没有抵抗力。 走路总是想到其中的情节，也总是叹气。明末千里行是我的第一部通的AVG。这或许就是所谓玩完gal的后劲吧。 类似的体验发生在我玩完《终焉之莉莉》后，看完《来自深渊》后，看完《声之形》后。但这种感觉，虽然有点难受，但我认为也是幸福的。 是享受完一部好作品后的怅惘，失落，也是等待续作时候都急切与希冀。这也是人生的意义所在啊。\n最近很急切的去补了一些明末历史和南明历史。买了顾明先生的《南明史》准备看。\n好喜欢满穗。\n说起莉莉，莉莉的续作木兰花其实让我失望。虽然乐在其中的玩完了，但是几乎没有留下印象深刻的情节。\n计划 看《南明史》，今天开始学 catlike coding for unity and C#。 继续跟着jyy2025年的课程学计算机系统。\n","date":"2025-03-11T00:00:00Z","image":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/mansui_huf44d5a27bdf3c47bbf41f99fa97b4ff1_472467_120x120_fill_q75_box_smart1.jpg","permalink":"https://entropy622.github.io/p/2025spring-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E4%B8%8A/","title":"2025spring 学期总结 上"},{"content":"2024fall 学期总结 暑假 暑假开始学c++，在leetcode上做了一些题，同时在学games101，但实际上，由于代码能力过于欠缺，101的作业只做了前面三个。收获并不大，需要在之后重修。\n八月份开始了解npr相关的东西，同时在看《Unity shader 入门精要》。学了一点HLSL。 开始用Unity URP 管线做点项目，磕磕绊绊做了几个星期，复刻了原和崩铁的渲染。\n实际效果看上去还不错，但可能很难应用到具体的项目中。\n九月 刚入学那会主要是熟悉了一下新环境，继续在leetcode上做点题，完善一下仿崩铁渲染的项目。同时，你知道的，连续玩了十几天黑神话。入坑了终焉的莉莉，看完了来自深渊，这是两部给我留下深刻印象的作品。\n十月 国庆节跟着学校的游戏研究社团参加了ld56（72h的gamejam）。国庆假的前四天主要是继续学习了unity的其他组件，跟教程做了一个2D top-down 游戏的小demo。为几天后的gamejam准备了一个简单的对话系统。\n国庆的后三天是非常紧张的gamejam。睡了两天的会议室。在最后一天，面对不敢相信能做完的工作量，熬到了十月八号凌晨六点终于做完了。第一次看到了龙大早上六点的太阳。\n很累，但是实在是我不可多得的宝贵经历。第一次接触比较大型的项目，第一次用git搞团队合作开发。开发能力也得到了很大的进步。\n做了一个横版2D游戏 但最后的排名并不好，后来我反思得出的结论是：做的体量太大，远远超出了一个gamejam应该有点体量（初次游玩大概一个小时），倒是最终我们只能实现一堆最基本的东西，而没有实现让一个游戏变得更好玩，更有趣的部分。 去了mihoyo的校招会，是我这个学期碰上最大的乐子 在学校的万圣节晚会上出了希露菲叶特\n转向luogu刷题了。gamejam后面的几个星期挺累的，没有做什么coding的项目。\n学了学blender，建模和风格化渲染的内容。跟着夏森轄的演示做了一个小人。 本来还想在blender里面复刻在unity中实现的仿崩铁渲染的，但是这个安排搁置了。\n十一月和十二月 入坑了csdiy https://csdiy.wiki/ 由于学校教的是java，所以我就从cs61b开始学了。说实话真的是一门很好的课。 project2 要求实现一个 mini git，是我收获最大的项目。 project3 实现了一个随机地图生成算法，以及一个小小的随机迷宫小游戏demo。也是很有意思的。 后面听说期末要考python，所以我在cs61b快学完的时候，也去把61a的lab和proj完成了。不得不说，仍然收获巨大。scheme，数据库，深入的匿名函数，函数指针，这些是在61b学不到的。 但是期末考试只考了一道很简单的python选择题\n学cs61学的十分起劲啊，学完61ab后一口做气又冲向了61c。但很快遇到了很大的挑战。首先是c语言编写的project1的环境配置，搞了很久没搞成。同时我也并不喜欢这个项目，于是就嫖了南大的c语言大作业来代替。主要内容是实现一个魔改、极简的命令行html解释器。 很有趣，也很有意思的项目。感谢南大。\n后面感觉自己对cs61c的学习兴趣远没有cs61ab大了，没有动力去做61c的大作业。于是在选取了部分61c的讲座听完后，我就放下了cs61c。\n这段时间我开始慢慢停止刷leetcode和luogu了，原因大概是三个。一是觉得刷题远没有做项目有意思，二是感觉一直刷题无法建立我的实际工程能力，三是我逐渐放弃了学期开始希望打ACM的打算。\n两个题站加起来总共刷了三百道，对我的帮助也是大的，不然学cs61的时候会遇到更多的困难。\n刷题虽好，不要沉迷。\n十二月下旬~至今 沉迷live2D，收集了b站的一堆免费皮套。天天对着VTS的面部摄像机挤眉弄眼。\n后来想把live2D形象放在桌面上，做成一个类似桌宠的玩意，但是苦于没有相关的插件，没有找到一个现成的好用的方案。\n然后我去学了一点点windows桌面应用开发。做了一个很小型的软件。期间最大的挑战是找不到一个能用的获取VTS虚拟摄像机的.net库。directShow虽然可以捕获到这个虚拟摄像头，但是输出不带透明度信息。\n于是想办法实现了一个简单的纯色背景去除算法，简单的hack了一下，让人物身上与背景相似的小色块不会被误除。 开始学黑马的web课程，在这过程中也准备搭一个个人博客。本来想从零手搓，但感觉太难了，放弃了。 之后采用hugo + stack的方案来搭建博客，同时引入了live2D桌宠。最后的成果就是这个网站。 未来规划 继续学黑马，学《计算机网络 自顶向下方法》。补完games101的作业。学UE。\n总结 这学期应该还是做了蛮多东西的。 当然是天天翘课导致的，一周下来只去上了体育课和英语课\n但我觉得我的目标变得不明确了。学期开始时候，我觉得我以后就是搞图形了。还去找了学校的图形学教授。但是现在我已经说不出这种话了。\n大一下学线代的时候（我现在已经开始第二学期的课程了），助教问我们矩阵乘法有什么意义，我回答了图形学中两个transformtion矩阵相乘的例子。助教下课问我是不是想搞图形学，我情不自禁回答了：“在学，但不会很深入。”\n转变的原因主要有两个吧：一是就业压力，在当前的环境下，图形学的前辈几乎都在劝退，我实在不敢在已经很糟糕的就业环境下，选择一条更加不好就业的道路。二是对困难的畏惧，图形确实挺难的。\n我似乎走上了一条更大众的道路。不过我也乐在其中，做web、wpf开发，也蛮有意思的。\n我对计算机的爱好还比较广泛。前端后端想搞，unity，ue想搞，blender也想搞，也有去学houdini的想法。有的时候会觉得自己学的东西似乎有点太杂了。\n应该尽快明确精进的方向。\n","date":"2025-01-18T00:00:00Z","image":"https://entropy622.github.io/p/2024fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/image_huf94238997220ab437e4c2645719d6d7e_184045_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/2024fall-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/","title":"2024fall 学期总结"},{"content":"图片 三级标题 四级标题 强调\n有序列表 有序列表 有序列表 ？？ 有序列表 10 11 五级^标题^ fklsjdlksjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfklsjdfkls 下划线 删除线 a上标 a下标 高亮\n链接 链接 [百度](URL_ADDRESS百度\n列表 $$ \\sum_{i=1}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} $$ $$ \\int_0^\\infty e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2} $$ $$\njack bush can 1 2 3 4 5 6 7 8 9 code 1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-01-17T00:00:00Z","image":"https://entropy622.github.io/p/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87/avatar_hud9e0e7c4951e871acf83365066e399f1_1041756_120x120_fill_box_smart1_3.png","permalink":"https://entropy622.github.io/p/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87/","title":"测试"}]